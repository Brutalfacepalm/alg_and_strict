# 2. Написать программу сложения и умножения двух шестнадцатеричных чисел. При этом каждое число представляется как массив,
# элементы которого — цифры числа. Например, пользователь ввёл A2 и C4F. Нужно сохранить их как [‘A’, ‘2’]
# и [‘C’, ‘4’, ‘F’] соответственно. Сумма чисел из примера: [‘C’, ‘F’, ‘1’], произведение - [‘7’, ‘C’, ‘9’, ‘F’, ‘E’].

# Примечание: Если воспользоваться функциями hex() и/или int() для преобразования систем счисления,
# задача решается в несколько строк. Для прокачки алгоритмического мышления такой вариант не подходит.
# Поэтому использование встроенных функций для перевода из одной системы счисления в другую в данной задаче под запретом.
# Вспомните начальную школу и попробуйте написать сложение и умножение в столбик.
from collections import defaultdict, deque

HEX = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']

hex_num_1 = {str(i + 1): v for i, v in
             enumerate(reversed(list(input('Введите первое число в шестнадцатиричной системе счисления: '))))}
hex_num_2 = {str(i + 1): v for i, v in
             enumerate(reversed(list(input('Введите второе число в шестнадцатиричной системе счисления: '))))}

ddict_hex_1 = defaultdict(int, **hex_num_1)
ddict_hex_2 = defaultdict(int, **hex_num_2)


def to_str(dd):
    deq = deque()
    dd = [*dd.values()]
    # проверяем не попал ли лишний старший разряд
    if dd[-1] == '0' and len(dd) > 1:
        dd.pop()
    for i in dd:
        deq.appendleft(i)
    s = ''.join(deq)
    return s

def sum_hex(dd1, dd2):
    s = defaultdict(int)
    for k in dd1.keys():
        rank = HEX.index(str(dd1[k])) + HEX.index(str(dd2[k]))
        if rank < len(HEX):
            s[k] += rank
            if s[k] >= 16:
                s[k] -= 16
                s[str(int(k) + 1)] += 1
        else:
            rank = rank - 16
            s[k] += rank
            s[str(int(k) + 1)] += 1
            if s[k] >= 16:
                s[k] -= 16
                s[str(int(k) + 1)] += 1
    s = defaultdict(int, **{i: HEX[v] for i, v in s.items()})
    return s


def multi_hex(dd1, dd2):
    # dd1, dd2 - defaultdict вводимых чисел. dd1 не обязательно соответствует первому вводимому числу, как и dd2 - второму
    # от перестановки мест слагаемых - сумма не меняется
    # рабочая сумма для разряда / первое слогаемое для суммирования после умножение по разряду
    multi_1 = defaultdict(int)
    # второе слогаемое для суммирование после умножения по разряду
    multi_2 = defaultdict(int)
    # k_1, k_2 это разряды чисел
    for k_2 in dd2.keys():
        # проверяем, не дошли ли до несуществующего ключа в словаре меньшего числа
        if dd2[k_2] == 0:
            break
        # обнуляем рабочую сумму по разрядам для чистого умножения нового разряда
        multi_1 = defaultdict(int, )
        k_1_s = ''
        for k_1 in dd1.keys():
            # ключ для повышения разряда после первого сложения в умножении столбиком
            k_1_s = str(int(k_1) + int(k_2) - 1)
            rank = HEX.index(str(dd1[k_1])) * HEX.index(str(dd2[k_2]))
            if rank < len(HEX):
                multi_1[k_1_s] += rank
                # проверяем, не нужно ли разбить на разряды после сложения
                if multi_1[k_1_s] >= 16:
                    multi_1[k_1_s] -= 16
                    multi_1[str(int(k_1_s) + 1)] += 1
            # если нужно перенести разряды
            else:
                for i in range(1, 16):
                    if rank - 16 * i < 16:
                        # высчитываем число текущего разряда и число разряда "в уме"
                        rank = rank - 16 * i
                        multi_1[k_1_s] += rank
                        multi_1[str(int(k_1_s) + 1)] += i
                        # проверяем, не нужно ли разбить на разряды после сложения
                        if multi_1[k_1_s] >= 16:
                            multi_1[k_1_s] -= 16
                            multi_1[str(int(k_1_s) + 1)] += 1
                        break
        # переводим в HEX формат
        multi_1 = defaultdict(int, **{str(i): HEX[multi_1[str(i)]] for i in range(1, int(k_1_s)+2)})
        # проверяем, если умножение произошло на двух разрядах, то складываем их
        if int(k_2) > 1:
            multi_1 = sum_hex(multi_1, multi_2)
        # помещаем сложение на одном разряде или сложение после двух разрядом во второе слагаемое для последующего сложения
        multi_2 = multi_1
    return multi_1


if len(ddict_hex_1) >= len(ddict_hex_2):
    print(f'Сумма - {to_str(sum_hex(ddict_hex_1, ddict_hex_2))}')
    print(f'Произведение - {to_str(multi_hex(ddict_hex_1, ddict_hex_2))}')
else:
    print(f'Сумма - {to_str(sum_hex(ddict_hex_2, ddict_hex_1))}')
    print(f'Произведение - {to_str(multi_hex(ddict_hex_2, ddict_hex_1))}')

# int тут использовался, но не для непосредственной работы с вводимыми числами, а для работы с ключами и индексами

# Введите первое число в шестнадцатиричной системе счисления: A2
# Введите второе число в шестнадцатиричной системе счисления: C4F
# Сумма - CF1
# Произведение - 7C9FE
# Введите первое число в шестнадцатиричной системе счисления: 0
# Введите второе число в шестнадцатиричной системе счисления: 1
# Сумма - 1
# Произведение - 0
# Введите первое число в шестнадцатиричной системе счисления: A01
# Введите второе число в шестнадцатиричной системе счисления: C4F
# Сумма - 1650
# Произведение - 7B224F
# Введите первое число в шестнадцатиричной системе счисления: A10
# Введите второе число в шестнадцатиричной системе счисления: C4F
# Сумма - 165F
# Произведение - 7BDAF0
# Введите первое число в шестнадцатиричной системе счисления: A0
# Введите второе число в шестнадцатиричной системе счисления: C4F
# Сумма - CEF
# Произведение - 7B160
# Введите первое число в шестнадцатиричной системе счисления: 0
# Введите второе число в шестнадцатиричной системе счисления: 0
# Сумма - 0
# Произведение - 0
# Введите первое число в шестнадцатиричной системе счисления: F
# Введите второе число в шестнадцатиричной системе счисления: F
# Сумма - 1E
# Произведение - E1